phpDownloadsDocumentationGet InvolvedHelp Объекты » « Строки Руководство по PHP Справочник языка Типы Change language: Edit Report a Bug Массивы ¶ На самом деле массив в PHP - это упорядоченное отображение, которое устанавливает соответствие между значением и ключом. Этот тип оптимизирован в нескольких направлениях, поэтому вы можете использовать его как собственно массив, список (вектор), хэш-таблицу (являющуюся реализацией карты), словарь, коллекцию, стэк, очередь и, возможно, что-то еще. Так как значением массива может быть другой массив PHP, можно также создавать деревья и многомерные массивы. Объяснение этих структур данных выходит за рамки данного справочного руководства, но вы найдете как минимум один пример по каждой из них. За дополнительной информацией вы можете обратиться к соответствующей литературе по этой обширной теме. Синтаксис ¶ Определение при помощи array() ¶ Массив (тип array) может быть создан языковой конструкцией array(). language construct. В качестве параметров она принимает любое количество разделенных запятыми пар key => value (ключ => значение). array( key => value, key2 => value2, key3 => value3, ... ) Запятая после последнего элемента массива необязательна и может быть опущена. Обычно это делается для однострочных массивов, т.е. array(1, 2) предпочтительней array(1, 2, ). Для многострочных массивов с другой стороны обычно используется завершающая запятая, так как позволяет легче добавлять новые элементы в конец массива. Начиная с PHP 5.4 возможно использовать короткий синтаксис определения массивов, который заменяет языковую конструкцию array() на []. Пример #1 Простой массив "bar", "bar" => "foo", ); // Начиная с PHP 5.4 $array = [ "foo" => "bar", "bar" => "foo", ]; ?> key может быть либо типа integer, либо типа string. value может быть любого типа. Дополнительно с ключом key будут сделаны следующие преобразования: Строки, содержащие целое число будут преобразованы к типу integer. Например, ключ со значением "8" будет в действительности сохранен со значением 8. С другой стороны, значение "08" не будет преобразовано, так как оно не является корректным десятичным целым. Числа с плавающей точкой (тип float) также будут преобразованы к типу integer, т.е. дробная часть будет отброшена. Например, ключ со значением 8.7 будет в действительности сохранен со значением 8. Тип bool также преобразовываются к типу integer. Например, ключ со значением true будет сохранен со значением 1 и ключ со значением false будет сохранен со значением 0. Тип null будет преобразован к пустой строке. Например, ключ со значением null будет в действительности сохранен со значением "". Массивы (тип array) и объекты (тип object) не могут использоваться в качестве ключей. При подобном использовании будет генерироваться предупреждение: Недопустимый тип смещения (Illegal offset type). Если несколько элементов в объявлении массива используют одинаковый ключ, то только последний будет использоваться, а все другие будут перезаписаны. Пример #2 Пример преобразования типов и перезаписи элементов "a", "1" => "b", 1.5 => "c", true => "d", ); var_dump($array); ?> Результат выполнения данного примера: array(1) { [1]=> string(1) "d" } Так как все ключи в вышеприведенном примере преобразуются к 1, значение будет перезаписано на каждый новый элемент и останется только последнее присвоенное значение "d". Массивы в PHP могут содержать ключи типов integer и string одновременно, так как PHP не делает различия между индексированными и ассоциативными массивами. Пример #3 Смешанные ключи типов integer и string "bar", "bar" => "foo", 100 => -100, -100 => 100, ); var_dump($array); ?> Результат выполнения данного примера: array(4) { ["foo"]=> string(3) "bar" ["bar"]=> string(3) "foo" [100]=> int(-100) [-100]=> int(100) } Параметр key является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа integer, увеличенное на 1. Пример #4 Индексированные массивы без ключа Результат выполнения данного примера: array(4) { [0]=> string(3) "foo" [1]=> string(3) "bar" [2]=> string(5) "hello" [3]=> string(5) "world" } Возможно указать ключ только для некоторых элементов и пропустить для других: Пример #5 Ключи для некоторых элементов "c", "d", ); var_dump($array); ?> Результат выполнения данного примера: array(4) { [0]=> string(1) "a" [1]=> string(1) "b" [6]=> string(1) "c" [7]=> string(1) "d" } Как вы видите последнее значение "d" было присвоено ключу 7. Это произошло потому, что самое большое значение ключа целого типа перед этим было 6. Доступ к элементам массива с помощью квадратных скобок ¶ Доступ к элементам массива может быть осуществлен с помощью синтаксиса array[key]. Пример #6 Доступ к элементам массива "bar", 42 => 24, "multi" => array( "dimensional" => array( "array" => "foo" ) ) ); var_dump($array["foo"]); var_dump($array[42]); var_dump($array["multi"]["dimensional"]["array"]); ?> Результат выполнения данного примера: string(3) "bar" int(24) string(3) "foo" Замечание: Для доступа к элементам массива могут использоваться как квадратные, так и фигурные скобки (например, $array[42] и $array{42} означают одно и то же в вышеприведенном примере). С PHP 5.4 стало возможным прямое разыменование массива, возвращаемого в качестве результата вызова функции или метода. Раньше приходилось использовать временные переменные. С PHP 5.5 стало возможным прямое разыменование элементов у литерала массива. Пример #7 Разыменование массива Замечание: Попытка доступа к неопределенному ключу в массиве - это то же самое, что и попытка доступа к любой другой неопределенной переменной: будет сгенерирована ошибка уровня E_NOTICE, и результат будет NULL. Создание/модификация с помощью синтаксиса квадратных скобок ¶ Существующий массив может быть изменен явной установкой значений в нем. Это выполняется присвоением значений массиву array с указанием в скобках ключа. Кроме того, вы можете опустить ключ. В этом случае добавьте к имени переменной пустую пару скобок ([]). $arr[key] = value; $arr[] = value; // key может быть integer или string // value может быть любым значением любого типа Если массив $arr еще не существует, он будет создан. Таким образом, это еще один способ определить массив array. Однако такой способ применять не рекомендуется, так как если переменная $arr уже содержит некоторое значение (например, значение типа string из переменной запроса), то это значение останется на месте и [] может на самом деле означать доступ к символу в строке. Лучше инициализировать переменную путем явного присваивания значения. Для изменения определенного значения просто присвойте новое значение элементу, используя его ключ. Если вы хотите удалить пару ключ/значение, вам необходимо использовать функцию unset(). 1, 12 => 2); $arr[] = 56; // В этом месте скрипта это // то же самое, что и $arr[13] = 56; $arr["x"] = 42; // Это добавляет к массиву новый // элемент с ключом "x" unset($arr[5]); // Это удаляет элемент из массива unset($arr); // Это удаляет массив полностью ?> Замечание: Как уже говорилось выше, если ключ не был указан, то будет взят максимальный из существующих целочисленных (integer) индексов, и новым ключом будет это максимальное значение (в крайнем случае 0) плюс 1. Если целочисленных индексов еще нет, то ключом будет 0 (ноль). Учтите, что максимальное целое значение ключа не обязательно существует в массиве в данный момент. Оно могло просто существовать в массиве какое-то время, с тех пор как он был переиндексирован в последний раз. Следующий пример это иллюстрирует: $value) { unset($array[$i]); } print_r($array); // Добавляем элемент (обратите внимание, что новым ключом будет 5, вместо 0). $array[] = 6; print_r($array); // Переиндексация: $array = array_values($array); $array[] = 7; print_r($array); ?> Результат выполнения данного примера: Array ( [0] => 1 [1] => 2 [2] => 3 [3] => 4 [4] => 5 ) Array ( ) Array ( [5] => 6 ) Array ( [0] => 6 [1] => 7 ) Полезные функции ¶ Для работы с массивами существует достаточное количество полезных функций. Смотрите раздел функции для работы с массивами. Замечание: Функция unset() позволяет удалять ключи массива. Обратите внимание, что массив НЕ будет переиндексирован. Если вы действительно хотите поведения в стиле "удалить и сдвинуть", можно переиндексировать массив используя array_values(). 'один', 2 => 'два', 3 => 'три'); unset($a[2]); /* даст массив, представленный так: $a = array(1 => 'один', 3 => 'три'); а НЕ так: $a = array(1 => 'один', 2 => 'три'); */ $b = array_values($a); // Теперь $b это array(0 => 'один', 1 => 'три') ?> Управляющая конструкция foreach существует специально для массивов. Она предоставляет возможность легко пройтись по массиву. Что можно и нельзя делать с массивами ¶ Почему $foo[bar] неверно? ¶ Всегда заключайте в кавычки строковый литерал в индексе ассоциативного массива. К примеру, пишите $foo['bar'], а не $foo[bar]. Но почему? Часто в старых скриптах можно встретить следующий синтаксис: This is wrong, but it works. The reason is that this code has an undefined constant (bar) rather than a string ('bar' - notice the quotes). PHP may in the future define constants which, unfortunately for such code, have the same name. It works because PHP automatically converts a bare string (an unquoted string which does not correspond to any known symbol) into a string which contains the bare string. For instance, if there is no defined constant named bar, then PHP will substitute in the string 'bar' and use that. Замечание: Это не означает, что нужно всегда заключать ключ в кавычки. Нет необходимости заключать в кавычки константы или переменные, поскольку это помешает PHP обрабатывать их. Результат выполнения данного примера: Проверяем 0: Notice: Undefined index: $i in /path/to/script.html on line 9 Плохо: Хорошо: 1 Notice: Undefined index: $i in /path/to/script.html on line 11 Плохо: Хорошо: 1 Проверяем 1: Notice: Undefined index: $i in /path/to/script.html on line 9 Плохо: Хорошо: 2 Notice: Undefined index: $i in /path/to/script.html on line 11 Плохо: Хорошо: 2 Дополнительные примеры, демонстрирующие этот факт: 'apple', 'veggie' => 'carrot'); // Верно print $arr['fruit']; // apple print $arr['veggie']; // carrot // Неверно. Это работает, но из-за неопределенной константы с // именем fruit также вызывает ошибку PHP уровня E_NOTICE // // Notice: Use of undefined constant fruit - assumed 'fruit' in... print $arr[fruit]; // apple // Давайте определим константу, чтобы продемонстрировать, что // происходит. Мы присвоим константе с именем fruit значение 'veggie'. define('fruit', 'veggie'); // Теперь обратите внимание на разницу print $arr['fruit']; // apple print $arr[fruit]; // carrot // Внутри строки это нормально. Внутри строк константы не // рассматриваются, так что ошибки E_NOTICE здесь не произойдет print "Hello $arr[fruit]"; // Hello apple // С одним исключением: фигурные скобки вокруг массивов внутри // строк позволяют константам там находиться print "Hello {$arr[fruit]}"; // Hello carrot print "Hello {$arr['fruit']}"; // Hello apple // Это не будет работать и вызовет ошибку обработки, такую как: // Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING' // Это, конечно, также действует и с суперглобальными переменными в строках print "Hello $arr['fruit']"; print "Hello $_GET['foo']"; // Еще одна возможность - конкатенация print "Hello " . $arr['fruit']; // Hello apple ?> Если вы переведете error_reporting в режим отображения ошибок уровня E_NOTICE (например, такой как E_ALL), вы сразу увидите эти ошибки. По умолчанию error_reporting установлена их не отображать. Как указано в разделе синтаксис, внутри квадратных скобок ('[' и ']') должно быть выражение. Это означает, что можно писать вот так: Это пример использования возвращаемого функцией значения в качестве индекса массива. PHP известны также и константы: Обратите внимание, что E_ERROR - это такой же верный идентификатор, как и bar в первом примере. Но последний пример по сути эквивалентен такой записи: поскольку E_ERROR соответствует 1, и т.д. Так что же в этом плохого? Когда-нибудь в будущем, команда разработчиков PHP, возможно, пожелает добавить еще одну константу или ключевое слово, либо константа из другого кода может вмешаться и тогда у вас могут возникнуть проблемы. Например, вы уже не можете использовать таким образом слова empty и default, поскольку они являются зарезервированными ключевыми словами. Замечание: Повторим, внутри строки (string), заключенной в двойные кавычки, корректно не окружать индексы массива кавычками, поэтому "$foo[bar]" является верной записью. Более подробно почему - смотрите вышеприведенные примеры, а также раздел обработка переменных в строках. Преобразование в массив ¶ Для любого из типов: integer, float, string, boolean и resource, преобразование значения в массив дает результатом массив с одним элементом (с индексом 0), являющимся скалярным значением, с которого вы начали. Другими словами, (array)$scalarValue - это точно то же самое, что и array($scalarValue). Если вы преобразуете в массив объект (object), вы получите в качестве элементов массива свойства (переменные-члены) этого объекта. Ключами будут имена переменных-членов, с некоторыми примечательными исключениями: целочисленные свойства станут недоступны; к закрытым полям класса (private) спереди будет дописано имя класса; к защищенным полям класса (protected) спереди будет добавлен символ '*'. Эти добавленные значения с обоих сторон также имеют нулевые байты. Это может вызвать несколько неожиданное поведение: Вышеприведенный код покажет 2 ключа с именем 'AA', хотя один из них на самом деле имеет имя '\0A\0A'. Если вы преобразуете в массив значение NULL, вы получите пустой массив. Сравнение ¶ Массивы можно сравнивать при помощи функции array_diff() и операторов массивов. Примеры ¶ The array type in PHP is very versatile. Here are some examples: Тип массив в PHP является очень гибким, вот несколько примеров: 'red', 'taste' => 'sweet', 'shape' => 'round', 'name' => 'apple', 4 // ключом будет 0 ); $b = array('a', 'b', 'c'); // . . .полностью соответствует $a = array(); $a['color'] = 'red'; $a['taste'] = 'sweet'; $a['shape'] = 'round'; $a['name'] = 'apple'; $a[] = 4; // ключом будет 0 $b = array(); $b[] = 'a'; $b[] = 'b'; $b[] = 'c'; // после выполнения этого кода, $a будет массивом // array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round', // 'name' => 'apple', 0 => 4), а $b будет // array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c'). ?> Пример #8 Использование array() 4, 'OS' => 'Linux', 'lang' => 'english', 'short_tags' => true ); // исключительно числовые ключи $array = array( 7, 8, 0, 156, -10 ); // это то же самое, что и array(0 => 7, 1 => 8, ...) $switching = array( 10, // ключ = 0 5 => 6, 3 => 7, 'a' => 4, 11, // ключ = 6 (максимальным числовым индексом было 5) '8' => 2, // ключ = 8 (число!) '02' => 77, // ключ = '02' 0 => 12 // значение 10 будет перезаписано на 12 ); // пустой массив $empty = array(); ?> Пример #9 Коллекция Результат выполнения данного примера: Вам нравится red? Вам нравится blue? Вам нравится green? Вам нравится yellow? Изменение значений массива напрямую стало возможным с версии PHP 5 путем передачи их по ссылке. До этого необходим следующий обходной прием: Пример #10 Изменение элемента в цикле $color) { $colors[$key] = strtoupper($color); } print_r($colors); ?> Результат выполнения данного примера: Array ( [0] => RED [1] => BLUE [2] => GREEN [3] => YELLOW ) Следующий пример создает массив, начинающийся с единицы. Пример #11 Индекс, начинающийся с единицы 'Январь', 'Февраль', 'Март'); print_r($firstquarter); ?> Результат выполнения данного примера: Array ( [1] => 'Январь' [2] => 'Февраль' [3] => 'Март' ) Пример #12 Заполнение массива Массивы упорядочены. Вы можете изменять порядок элементов, используя различные функции сортировки. Для дополнительной информации смотрите раздел функции для работы с массивами. Вы можете подсчитать количество элементов в массиве с помощью функции count(). Пример #13 Сортировка массива Поскольку значение массива может быть чем угодно, им также может быть другой массив. Таким образом вы можете создавать рекурсивные и многомерные массивы. Пример #14 Рекурсивные и многомерные массивы array ( "a" => "апельсин", "b" => "банан", "c" => "яблоко" ), "числа" => array ( 1, 2, 3, 4, 5, 6 ), "дырки" => array ( "первая", 5 => "вторая", "третья" ) ); // Несколько примеров доступа к значениям предыдущего массива echo $fruits["дырки"][5]; // напечатает "вторая" echo $fruits["фрукты"]["a"]; // напечатает "апельсин" unset($fruits["дырки"][0]); // удалит "первая" // Создаст новый многомерный массив $juices["apple"]["green"] = "good"; ?> Обратите внимание, что при присваивании массива всегда происходит копирование значения. Чтобы скопировать массив по ссылке, вам нужно использовать оператор ссылки. 
!DOCTYPE html> phpDownloadsDocumentationGet InvolvedHelp Массивы » « Числа с плавающей точкой Руководство по PHP Справочник языка Типы Change language: Edit Report a Bug Строки ¶ Строка - это набор символов, где символ - это то же самое, что и байт. Это значит, что PHP поддерживает ровно 256 различных символов, а также то, что в PHP нет встроенной поддержки Unicode. Смотрите также подробности реализации строкового типа. Замечание: Строки (string) не могут быть размером более 2 Гб (2147483647 байт). Синтаксис ¶ Строка может быть определена четырьмя различными способами: одинарными кавычками двойными кавычками heredoc-синтаксисом nowdoc-синтаксисом (начиная с версии PHP 5.3.0) Одинарные кавычки ¶ Простейший способ определить строку - это заключить ее в одинарные кавычки (символ '). Чтобы использовать одинарную кавычку внутри строки, проэкранируйте ее обратной косой чертой (\). Если необходимо написать саму обратную косую черту, продублируйте ее (\\). Все остальные случаи применения обратной косой черты будут интерпретированы как обычные символы: это означает, что если вы попытаетесь использовать другие управляющие последовательности, такие как \r или \n, они будут выведены как есть вместо какого-либо особого поведения. Замечание: В отличие от синтаксиса двойных кавычек и heredoc, переменные и управляющие последовательности для специальных символов, заключенных в одинарные кавычки, не обрабатываются. Двойные кавычки ¶ Если строка заключена в двойные кавычки ("), PHP распознает большее количество управляющих последовательностей для специальных символов: Управляющие последовательности Последовательность	Значение \n	новая строка (LF или 0x0A (10) в ASCII) \r	возврат каретки (CR или 0x0D (13) в ASCII) \t	горизонтальная табуляция (HT или 0x09 (9) в ASCII) \v	вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5) \e	escape-знак (ESC или 0x1B (27) в ASCII) (с версии PHP 5.4.0) \f	подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5) \\	обратная косая черта \$	знак доллара \"	двойная кавычка \[0-7]{1,3}	последовательность символов, соответствующая регулярному выражению символа в восьмеричной системе счисления \x[0-9A-Fa-f]{1,2}	последовательность символов, соответствующая регулярному выражению символа в шестнадцатеричной системе счисления Как и в строке, заключенной в одинарные кавычки, экранирование любого символа выведет также и саму обратную косую черту. До версии PHP 5.1.1, обратная косая черта в \{$var} не печаталась. Но самым важным свойством строк в двойных кавычках является обработка переменных. Смотрите более подробно: обработка строк Heredoc ¶ Третий способ определения строк - это использование heredoc-синтаксиса: <<<. После этого оператора необходимо указать идентификатор, затем перевод строки. После этого идет сама строка, а потом этот же идентификатор, закрывающий вставку. Строка должна начинаться с закрывающего идентификатора, т.е. он должен стоять в первом столбце строки. Кроме того, идентификатор должен соответствовать тем же правилам именования, что и все остальные метки в PHP: содержать только буквенно-цифровые символы и знак подчеркивания, и не должен начинаться с цифры (знак подчеркивания разрешается). Внимание Очень важно отметить, что строка с закрывающим идентификатором не должна содержать других символов, за исключением точки с запятой (;). Это означает, что идентификатор не должен вводиться с отступом и что не может быть никаких пробелов или знаков табуляции до или после точки с запятой. Важно также понимать, что первым символом перед закрывающим идентификатором должен быть символ новой строки, определенный в вашей операционной системе. Например, в UNIX системах, включая Mac OS X, это \n. После закрывающего идентификатора также сразу должна начинаться новая строка. Если это правило нарушено и закрывающий идентификатор не является "чистым", считается, что закрывающий идентификатор отсутствует и PHP продолжит его поиск дальше. Если в этом случае верный закрывающий идентификатор так и не будет найден, то это вызовет ошибку парсинга с номером строки в конце скрипта. Heredoc не может быть использован для инициализации полей класса. Начиная с версии PHP 5.3, это ограничение распространяется только на heredoc, содержащие внутри себя переменные. Пример #1 Неверный пример Heredoc-текст ведет себя так же, как и строка в двойных кавычках, при этом их не имея. Это означает, что вам нет необходимости экранировать кавычки в heredoc, но вы по-прежнему можете использовать вышеперечисленные управляющие последовательности. Переменные обрабатываются, но с применением сложных переменных внутри heredoc нужно быть также внимательным, как и при работе со строками. Пример #2 Пример определения heredoc-строки foo = 'Foo'; $this->bar = array('Bar1', 'Bar2', 'Bar3'); } } $foo = new foo(); $name = 'МоеИмя'; echo <<foo. Теперь я вывожу {$foo->bar[1]}. Это должно вывести заглавную букву 'A': \x41 EOT; ?> Результат выполнения данного примера: Меня зовут "МоеИмя". Я печатаю Foo. Теперь, я вывожу Bar2. Это должно вывести заглавную букву 'A': A Также возможно использовать heredoc-синтаксис для передачи данных через аргументы функции: Пример #3 Пример применения heredoc в аргументах Начиная с версии 5.3.0, стала возможной инциализация статических переменных и свойств/констант класса с помощью синтаксиса heredoc: Пример #4 Использование heredoc для инциализации статических переменных Начиная с версии PHP 5.3.0 можно также окружать идентификатор Heredoc двойными кавычками: Пример #5 Использование двойных кавычек в heredoc Nowdoc ¶ Nowdoc - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок. Эта конструкция идеальна для внедрения PHP-кода или других больших блоков текста без необходимости его экранирования. В этом он немного похож на SGML-конструкцию тем, что объявляет блок текста, не предназначенный для обработки. Nowdoc указывается той же последовательностью <<<, что используется в heredoc, но последующий за ней идентификатор заключается в одинарные кавычки, например, <<<'EOT'. Все условия, действующие для heredoc идентификаторов также действительны и для nowdoc, особенно те, что относятся к закрывающему идентификатору. Пример #6 Пример использования nowdoc foo = 'Foo'; $this->bar = array('Bar1', 'Bar2', 'Bar3'); } } $foo = new foo(); $name = 'МоеИмя'; echo <<<'EOT' Меня зовут "$name". Я печатаю $foo->foo. Теперь я печатаю {$foo->bar[1]}. Это не должно вывести заглавную 'A': \x41 EOT; ?> Результат выполнения данного примера: Меня зовут "$name". Я печатаю $foo->foo. Теперь я печатаю {$foo->bar[1]}. Это не должно вывести заглавную 'A': \x41 Замечание: В отличие от heredoc, nowdoc может быть использован в любом контексте со статическими данными. Типичный пример инициализации полей класса или констант: Пример #7 Пример использования статичных данных Замечание: Поддержка nowdoc была добавлена в PHP 5.3.0. Обработка переменных ¶ Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри нее обрабатываются. Существует два типа синтаксиса: простой и сложный. Простой синтаксис более легок и удобен. Он дает возможность обработки переменной, значения массива (array) или свойства объекта (object) с минимумом усилий. Сложный синтаксис может быть определен по фигурным скобкам, окружающим выражение. Простой синтаксис Если интерпретатор встречает знак доллара ($), он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. Если вы хотите точно определить конец имени, заключайте имя переменной в фигурные скобки. Результат выполнения данного примера: He drank some apple juice. He drank some juice made of . Аналогично могут быть обработаны элемент массива (array) или свойство объекта (object). В индексах массива закрывающая квадратная скобка (]) обозначает конец определения индекса. Для свойств объекта применяются те же правила, что и для простых переменных. Пример #8 Пример простого синтаксиса "purple"); echo "He drank some $juices[0] juice.".PHP_EOL; echo "He drank some $juices[1] juice.".PHP_EOL; echo "He drank some $juices[koolaid1] juice.".PHP_EOL; class people { public $john = "John Smith"; public $jane = "Jane Smith"; public $robert = "Robert Paulsen"; public $smith = "Smith"; } $people = new people(); echo "$people->john drank some $juices[0] juice.".PHP_EOL; echo "$people->john then said hello to $people->jane.".PHP_EOL; echo "$people->john's wife greeted $people->robert.".PHP_EOL; echo "$people->robert greeted the two $people->smiths."; // Won't work ?> Результат выполнения данного примера: He drank some apple juice. He drank some orange juice. He drank some purple juice. John Smith drank some apple juice. John Smith then said hello to Jane Smith. John Smith's wife greeted Robert Paulsen. Robert Paulsen greeted the two . Для чего-либо более сложного, используйте сложный синтаксис. Сложный (фигурный) синтаксис Он называется сложным не потому, что труден в понимании, а потому что позволяет использовать сложные выражения. Любая скалярная переменная, элемент массива или свойство объекта, отображаемое в строку, может быть представлена в строке этим синтаксисом. Просто запишите выражение так же, как и вне строки, а затем заключите его в { и }. Поскольку { не может быть экранирован, этот синтаксис будет распознаваться только когда $ следует непосредственно за {. Используйте {\$, чтобы напечатать {$. Несколько поясняющих примеров: width}00 сантиметров."; // Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок echo "Это работает: {$arr['key']}"; // Работает echo "Это работает: {$arr[4][3]}"; // Это неверно по той же причине, что и $foo[bar] вне // строки. Другими словами, это по-прежнему будет работать, // но поскольку PHP сначала ищет константу foo, это вызовет // ошибку уровня E_NOTICE (неопределенная константа). echo "Это неправильно: {$arr[foo][3]}"; // Работает. При использовании многомерных массивов внутри // строк всегда используйте фигурные скобки echo "Это работает: {$arr['foo'][3]}"; // Работает. echo "Это работает: " . $arr['foo'][3]; echo "Это тоже работает: {$obj->values[3]->name}"; echo "Это значение переменной по имени $name: {${$name}}"; echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}"; echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}"; // Не работает, выводит: Это то, что возвращает getName(): {getName()} echo "Это то, что возвращает getName(): {getName()}"; ?> С помощью этого синтаксиса также возможен доступ к свойствам объекта внутри строк. $bar}\n"; echo "{$foo->$baz[1]}\n"; ?> Результат выполнения данного примера: I am bar. I am bar. Замечание: Функции, вызовы методов, статические переменные классов, а также константы классов работает внутри {$}, начиная с версии PHP 5. Однако, указываемое значение будет обработано как имя переменной в том же контексте, что и строка, в которой она определяется. Использование одинарных фигурных скобок ({}) не будет работать для доступа к значениям функций, методов, констант классов или статических переменных класса. Доступ к символу в строке и его изменение ¶ Символы в строках можно использовать и модифицировать, определив их смещение относительно начала строки, начиная с нуля, в квадратных скобках после строки, например, $str[42]. Думайте о строке для этой цели, как о массиве символов. Если нужно получить или заменить более 1 символа, можно использовать функции substr() и substr_replace(). Замечание: К символу в строке также можно обращаться с помощью фигурных скобок, например, $str{42}. Внимание Попытка записи в смещение за границами строки дополнит строку пробелами до этого смещения. Нецелые типы будет преобразованы в целые. Неверный тип смещения вызовет ошибку уровня E_NOTICE. Запись по отрицательному смещению вызовет ошибку уровня E_NOTICE, а при чтении вернет пустую строку. Используется только первый символ присваемой строки. Присвоение пустой строки присваивает нулевой байт (NULL). Внимание Строки в PHP внутренне представляют из себя массивы байт. Как результат, доступ или изменение строки по смещению небезопасно с точки зрения многобайтной кодировки, и должно выполняться только со строками в однобайтных кодировках, таких как, например, ISO-8859-1. Пример #9 Несколько примеров строк Начиная с PHP 5.4 смещение в строке должно задаваться либо целым числом либо строкой, содержащей цифры, иначе будет выдаваться предупреждение. Ранее смещение, заданное строкой вида "foo", без предупреждений преобразовывалось в 0. Пример #10 Различия между PHP 5.3 и PHP 5.4 Результат выполнения данного примера в PHP 5.3: string(1) "b" bool(true) string(1) "b" bool(true) string(1) "a" bool(true) string(1) "b" bool(true) Результат выполнения данного примера в PHP 5.4: string(1) "b" bool(true) Warning: Illegal string offset '1.0' in /tmp/t.php on line 7 string(1) "b" bool(false) Warning: Illegal string offset 'x' in /tmp/t.php on line 9 string(1) "a" bool(false) string(1) "b" bool(false) Замечание: Попытка доступа к переменным других типов (исключая массивы или объекты, реализующие определенные интерфейсы) с помощью [] или {} молча вернет NULL. Замечание: В PHP 5.5 была добавлена поддержка доступа к символам в строковых литералах с помощью синтаксиса [] или {}. Полезные функции и операторы ¶ Строки могут быть объединены при помощи оператора '.' (точка). Обратите внимание, оператор сложения '+' здесь не работает. Дополнительную информацию смотрите в разделе Строковые операторы. Для модификации строк существует множество полезных функций. Основные функции описаны в разделе строковых функций, а для расширенного поиска и замены - функции регулярных выражений или Perl-совместимых регулярных выражений. Также существуют функции для работы с URL, и функции шифрования/дешифрования строк (mcrypt и mhash). Наконец, смотрите также функции символьных типов. Преобразование в строку ¶ Значение может быть преобразовано в строку, с помощью приведения (string), либо функции strval(). В выражениях, где необходима строка, преобразование происходит автоматически. Это происходит, когда вы используете функции echo или print, либо когда значение переменной сравнивается со строкой. Прочтение разделов руководства Типы и Манипуляции с типами сделает следующее более понятным. Смотрите также settype(). Значение boolean TRUE преобразуется в строку "1", а значение FALSE преобразуется в "" (пустую строку). Это позволяет преобразовывать значения в обе стороны - из булева типа в строковый и наоборот. Целое (integer) или число с плавающей точкой (float) преобразуется в строку, представленную числом, состоящим из его цифр (включая показатель степени для чисел с плавающей точкой). Числа с плавающей точкой могут быть преобразованы с помощью экспоненциального представления (4.1E+6). Замечание: Символ десятичной точки определяется из настроек локали текущего скрипта (категория LC_NUMERIC). Смотрите также setlocale(). Массивы всегда преобразуются в строку "Array", так что вы не можете отобразить содержимое массива (array), используя echo или print, чтобы узнать, что он содержит. Чтобы просмотреть отдельный элемент, используйте что-нибудь вроде echo $arr['foo']. Смотрите ниже советы о том, как отобразить/просмотреть все содержимое. Объекты в PHP 4 всегда преобразовывались в строку "Object". Если вы хотите вывести значения полей объекта (object) с целью отладки, читайте дальше. Если вы хотите получить имя класса требуемого объекта, используйте get_class(). Начиная с PHP 5, также стал доступен метод __toString. Resource всегда всегда преобразуется в string вида "Resource id #1", где 1 является номером ресурса привязанного к resource во время выполнения. И хотя не стоит точно полагаться на эту строку, которая может быть изменена в будущем, она всегда будет уникальной для текущего запуска скрипта (т.е. web-азпроса или CLI-процесса) и не может использоваться повторно для другого ресурса. Если вы хотите получить тип ресурса, используйте get_resource_type(). NULL всегда преобразуется в пустую строку. Как вы могли видеть выше, прямое преобразование в строку массивов, объектов или ресурсов не дает никакой полезной информации о самих значениях, кроме их типов. Более подходящий способ вывода значений для отладки - использовать функции print_r() и var_dump(). Большинство значений в PHP может быть преобразовано в строку для постоянного хранения. Этот метод называется сериализацией и может быть выполнен при помощи функции serialize(). Кроме того, если в вашей установке PHP есть поддержка WDDX, возможна также сериализация в XML-структуру. Преобразование строк в числа ¶ Если строка распознается как числовое значение, результирующее значение и тип определяется так, как показано далее. Если строка не содержит какой-либо из символов '.', 'e', или 'E', и значение числа помещается в пределы целых чисел (определенных PHP_INT_MAX), строка будет распознана как целое число (integer). Во всех остальных случаях она считается числом с плавающей точкой (float). Значение определяется по начальной части строки. Если строка начинается с верного числового значения, будет использовано это значение. Иначе значением будет 0 (ноль). Верное числовое значение - это одна или более цифр (могущих содержать десятичную точку), по желанию предваренных знаком, с последующим необязательным показателем степени. Показатель степени - это 'e' или 'E' с последующими одной или более цифрами. Более подробную информацию об этом преобразовании смотрите в разделе о strtod(3) документации Unix. Если вы хотите протестировать любой из примеров этого раздела, скопируйте и вставьте его и следующую строку, чтобы увидеть, что происходит: \n"; ?> Не ожидайте получить код символа, преобразовав его в целое (как это делается, например, в C). Для преобразования символов в их ASCII коды и обратно используйте функции ord() и chr(). Подробности реализации строкового типа ¶ Строковый тип (string) в PHP реализован в виде массива байт и целого числа, содержащего длину буфера. Он не содержит никакой информации о способе преобразования этих байт в символы, предоставляя эту задачу программисту. Нет никаких ограничений на содержимое строки, например, байт со значением 0 ("NUL"-байт) может располагаться где угодно (однако, стоит учитывать, что некоторые функции, как сказано в этом руководстве, не явлляются "бинарно-безопасными", т.е. они могут передавать строки библиотекам, которые игнорируют данные после NUL-байта). Данная природа строкового типа объясняет почему в PHP нет отдельного типа “byte” - строки играют эту роль. Функции, возвращающие нетекстовые данные - например, произвольный поток данных, считываемый из сетевого сокета - тем не менее возвращают строки. Принимая во внимание тот факт, что PHP не диктует определенную кодировку для строк, можно задать вопрос, как в таком случае кодируются стрковые литералы. Например, строка "á" эквивалентна "\xE1" (ISO-8859-1), "\xC3\xA1" (UTF-8, форма нормализации C), "\x61\xCC\x81" (UTF-8, форма нормализации D) или какому-либо другому возможному представлению? Ответом является следующее: строка будет закодирована тем образом, которым она записана в файле скрипта. Таким образом, если скрипт записан в кодировке ISO-8859-1, то и строка будет закодирована в ISO-8859-1 и т.д. Однако, это правило не применяется при включенном режиме Zend Multibyte: в этом случае скрипт может быть записан в любой кодировке (которая указывается ясно или определяется автоматически), а затем конвертируются в определенную внутреннюю кодировку, которая и будет впоследствии использована для строковых литералов. Учтите, что на кодировку скрипта (или на внутреннюю кодировку, если включен режим Zend Multibyte) накладываются некоторые ограничения: практически всегда данная кодировка должна быть надмножеством ASCII, например, UTF-8 или ISO-8859-1. Учтите также, что кодировки, зависящие от состояния, где одни и те же значения байт могут быть использованы в начальном и неначальном состоянии сдвига (initial and non-inital shift state), могут вызвать проблемы. Разумеется, чтобы приносить пользу, строковые функции должны сделать некоторые предположения о кодировке строки. К несчастью, среди PHP-функций довольно большое разнообразие подходов к этому вопросу: Некоторые функции предполагают, что строка закодирована в какой-либо однобайтовой кодировке, однако, для корректной работы им не требуется интерпретировать байты как определенные символы. Под эту категорию попадают, например, substr(), strpos(), strlen() и strcmp(). Другой способ мышления об этих функциях представляет собой оперирование буферами памяти, т.е. они работают непосредственно с байтами и их смещениями. offsets. Другие функции ожидают передачу кодировку в виде параметра, возможно, предполагая некоторую кодировку по умолчанию, если параметр с кодировкой не был указан. Такой функцией является htmlentities() и большинство функций из расширения mbstring. Другие функции используют текущие установки локали (см. setlocale()), но оперируют побайтово). В эту категорию попадают strcasecmp(), strtoupper() и ucfirst(). Это означает, что они могут быть использованы только с однобайтовыми кодировками, в том случае, когда кодировка совпадает с локалью. Например, strtoupper("á") может вернуть "Á", если локаль установлена корректно и буква á закодирована в виде одного байта. Если она закодирована в UTF-8, будет возвращен некорректный результат, и, в зависимости от текущей локали, результирующая строка может быть (или не быть) испорчена. Наконец, есть функции, подразумевающие, что строка использует определенную кодировку, обычно UTF-8. Сюда попадают большинство функций из расширений intl и PCRE (в последнем случае, только при указании модификатора u). Хотя это и сделано специально, функция utf8_decode() подразумевает кодировку UTF-8, а utf8_encode() - ISO-8859-1. В конечном счете, написание корректных программ, работающих с Unicode, означает осторожное избегание функций, которые не работают с Unicode и, скорее всего, испортят данные, и использование вместо них корректных функций, обычно из расширений intl и mbstring. Однако, использование функций, способных работать с Unicode, является самым началом. Вне зависимости от тех функций, которые предоставляет язык, необходимо знать спецификацию самого Unicode. Например, если программа предполагает существование в языке только строчных и заглавных букв, то она делает большую ошибку.
!DOCTYPE html> phpDownloadsDocumentationGet InvolvedHelp Свойства » « Введение Руководство по PHP Справочник языка Классы и объекты Change language: Edit Report a Bug Основы ¶ class ¶ Каждое определение класса начинается с ключевого слова class, затем следует имя класса, и далее пара фигурных скобок, которые заключают в себе определение свойств и методов этого класса. Именем класса может быть любое слово, при условии, что оно не входит в список зарезервированных слов PHP, начинается с буквы или символа подчеркивания и за которым следует любое количество букв, цифр или символов подчеркивания. Если задать эти правила в виде регулярного выражения, то получится следующее выражение: ^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$. Класс может содержать собственные константы, переменные (называемые свойствами) и функции (называемые методами). Пример #1 Простое определение класса ?php class SimpleClass { // объявление свойства public $var = 'значение по умолчанию'; // объявление метода public function displayVar() { echo $this->var; } } ?> Псевдо-переменная $this доступна в том случае, если метод был вызван в контексте объекта. $this является ссылкой на вызываемый объект. Обычно это тот объект, которому принадлежит вызванный метод, но может быть и другой объект, если метод был вызван статически из контекста другого объекта. Это показано на следующих примерах: Пример #2 Переменная $this ?php class A { function foo() { if (isset($this)) { echo '$this определена ('; echo get_class($this); echo ")\n"; } else { echo "\$this не определена.\n"; } } } class B { function bar() { // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT. A::foo(); } } $a = new A(); $a->foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT. A::foo(); $b = new B(); $b->bar(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT. B::bar(); ?> Результат выполнения данного примера: $this определена (A) $this не определена. $this определена (B) $this не определена. new ¶ Для создания экземпляра класса используется директива new. Новый объект всегда будет создан, за исключением случаев, когда он содержит конструктор, в котором определен вызов исключения в случае ошибки. Рекомендуется определять классы до создания их экземпляров (в некоторых случаях это обязательно). Если с директивой new используется строка (string), содержащая имя класса, то будет создан новый экземпляр этого класса. Если имя находится в пространстве имен, то оно должно быть задано полностью. Пример #3 Создание экземпляра класса ?php $instance = new SimpleClass(); // Это же можно сделать с помощью переменной: $className = 'Foo'; $instance = new $className(); // Foo() ?> В контексте класса можно создать новый объект через new self и new parent. Когда происходит присвоение уже существующего экземпляра класса новой переменной, то эта переменная будет указывать на этот же экземпляр класса. Тоже самое происходит и при передаче экземпляра класса в функцию. Копию уже созданного объекта можно создать через ее клонирование. Пример #4 Присваивание объекта ?php $instance = new SimpleClass(); $assigned = $instance; $reference =& $instance; $instance->var = '$assigned будет иметь это значение'; $instance = null; // $instance и $reference становятся null var_dump($instance); var_dump($reference); var_dump($assigned); ?> Результат выполнения данного примера: NULL NULL object(SimpleClass)#1 (1) { ["var"]=> string(30) "$assigned будет иметь это значение" } В PHP 5.3.0 введены несколько новых методов создания экземпляров объекта: Пример #5 Создание новых объектов class Test { static public function getNew() { return new static; } } class Child extends Test {} $obj1 = new Test(); $obj2 = new $obj1; var_dump($obj1 !== $obj2); $obj3 = Test::getNew(); var_dump($obj3 instanceof Test); $obj4 = Child::getNew(); var_dump($obj4 instanceof Child); ?> Результат выполнения данного примера: bool(true) bool(true) bool(true) extends ¶ Класс может наследовать методы и свойства другого класса используя ключевое слово extends при его описании. Невозможно наследовать несколько классов, один класс может наследовать только один базовый класс. Наследуемые методы и свойства могут быть переопределены (за исключением случаев, когда метод класса объявлен как final) путем объявления их с теми же именами, как и в родительском классе. Существует возможность доступа к переопределенным методам или статическим методам путем обращения к ним через parent:: Когда переопределяются методы число и типы аргументов должны оставаться такими же как и были, иначе PHP вызовет ошибку уровня E_STRICT. Это не относится к конструктору, который можно переопределить с другими параметрами. Пример #6 Простое наследование классов class ExtendClass extends SimpleClass { // Переопределение метода родителя function displayVar() { echo "Расширенный класс\n"; parent::displayVar(); } } $extended = new ExtendClass(); $extended->displayVar(); ?> Результат выполнения данного примера: Расширенный класс значение по умолчанию ::class ¶ Начиная с версии PHP 5.5 можно использовать ключевое слово class для разрешения имени класса. С помощью конструкции ClassName::class можно получить строку с абсолютным именем класса ClassName. Обычно это довольно полезно при работе с классами, использующими пространства имен. Пример #7 Разрешение имени класса namespace NS { class ClassName { } echo ClassName::class; } ?> Результат выполнения данного примера: NS\ClassName 
!DOCTYPE html> phpDownloadsDocumentationGet InvolvedHelp Константы классов » « Основы Руководство по PHP Справочник языка Классы и объекты Change language: Edit Report a Bug Свойства ¶ Переменные, которые являются членами класса, называются "свойства". Также их называют, используя другие термины, такие как "аттрибуты" или "поля", но в рамках этой документации, мы будем называть их свойствами. Они определяются с помощью ключевых слов public, protected, или private, следуя правилам правильного описания переменных. Это описание может содержать инициализацию, но инициализация дожна применяться для константных значений - то есть, переменные должны быть вычислены во время компиляции и не должны зависеть от информации программы во время выполнения для их вычисления. Смотри Область видимости для получения информации о применении public, protected, и private. Замечание: Для того, чтобы поддерживать обратную совместимость с PHP 4, PHP 5 по-прежнему позволяет использовать ключевое слово var при определении свойств вместо (или в дополнении к) public, protected, или private. Однако, var больше не требуется. В версиях PHP с 5.0 по 5.1.3, использование var считалось устаревшим вызывало E_STRICT предупреждение, но с PHP 5.1.3 больше не считается устаревшим и не выдает предупреждения. Если, для определения свойства, вы используете var вместо одного из: public, protected, или private, тогда PHP 5 будет определять свойство как public. В пределах методов класса доступ к нестатическим свойствам может быть получен с помощью -> (объектного оператора): $this->property (где property - имя свойства). Доступ к статическим свойствам может быть получен с помощью :: (двойного двоеточия): self::$property. Подробнее о различиях между статическими и нестатическими свойствами смотрите в разделе "Ключевое слово Static" для получения большей информации. Псевдо-переменная $this доступна внутри любого метода класса, когда этот метод вызывается в пределах объекта. $this - это ссылка на вызываемый объект (обычно, объект, которому принадлежит метод, но возможно и другого объекта, если метод вызван статически из контекста второго объекта). Пример #1 Определение свойств Замечание: Существуют несколько интересных функций для обработки классов и объектов. Вы можете их увидеть тут Class/Object Functions. В отличии от heredocs, nowdocs может быть использованы в любом статическом контексте данных, включая определение свойств. Пример #2 Пример использования nowdoc для инициализации свойств Замечание: Поддержка nowdoc была добавлена в PHP 5.3.0.
!DOCTYPE html> phpDownloadsDocumentationGet InvolvedHelp Автоматическая загрузка классов » « Свойства Руководство по PHP Справочник языка Классы и объекты Change language: Edit Report a Bug Константы классов ¶ Константы также могут быть объявлены и в пределах одного класса. Отличие переменных и констант состоит в том, что при объявлении последних или при обращении к ним не используется символ $. Значение должно быть неизменяемым выражением, не (к примеру) переменной, свойством, результатом математической операции или вызовом функции. Интерфейсы также могут содержать константы (constants). За примерами обращайтесь к разделу об интерфейсах. Начиная с версии PHP 5.3.0, стало возможным обратиться к классу с помощью переменной. Значение переменной не должно быть ключевым словом (например, self, parent или static). Пример #1 Объявление и использование константы ?php class MyClass { const CONSTANT = 'значение константы'; function showConstant() { echo self::CONSTANT . "\n"; } } echo MyClass::CONSTANT . "\n"; $classname = "MyClass"; echo $classname::CONSTANT . "\n"; // начиная с версии PHP 5.3.0 $class = new MyClass(); $class->showConstant(); echo $class::CONSTANT."\n"; // начиная с версии PHP 5.3.0 ?> Пример #2 Пример со статичными данными ?php class foo { // Начиная с версии PHP 5.3.0 const BAR = <<<'EOT' bar EOT; } ?> В отличие от heredoc, nowdoc может быть использован в любом контексте статичных данных. Замечание: Поддержка nowdoc была добавлена в версии PHP 5.3.0.
    !DOCTYPE html> IEEE TRANSACTIONS ON ACOUSTICS, SPEECH, AND SIGNAL PROCESSING, VOL. ASSP-29, NO. 4, AUGUST 1981 777 An Improved Endpoint Detector for Isolated Word Recognition LORI F. LAMEL, STUDENT MEMBER, IEEE, LAWRENCE R. RABINER, FELLOW, IEEE, AARON E. ROSENBERG, MEMBER, IEEE, AND JAY G. WILPON Abstract—Accurate location of the endpoints of an isolated word is important for reliable and robust word recognition. The endpoint detection problem is nontrivial for nonstationary backgrounds where artifacts (i.e., nonspeech events) may be introduced by the speaker, the recording environment, and the transmission system. Several techniques for the detection of the endpoints of isolated words recorded over a dialed-up telephone line were studied. The techniques were broadly classified as either explicit, implicit, or hybrid in concept. The explicit techniques for endpoint detection locate the endpoints prior to and independent of the recognition and decision stages of the system. For the implicit methods, the endpoints are determined solely by the recognition and decision stages Of the system, i.e., there is no separate stage for endpoint detection. The hybrid techniques incorporate aspects from both the explicit and implicit methods. Investigations showed that the hybrid techniques consistently provided the best estimates for both of the word endpoints and, correspondingly, the highest recognition accuracy of the three classes studied. A hybrid endpoint detector is proposed which gives a rejection rate of less than 0.5 percent, while providing recognition accuracy close to that obtained from hand-edited endpoints. I. INTRODUCTION ISOLATED word recognition is based on the premise that the signal in a prescribed recording interval consists of an isolated word, preceded and followed by silence or other background noise. Thus, when a word is actually spoken, it is assumed that the speech segments can be reliably separated from the nonspeech segments. (Clearly, in the case when there is no speech in the recording interval, a request to repeat the spoken word must be made.) The process of separating the speech segments of an utterance from the background, i.e., the nonspeech segments obtained during the recording process, is called endpoint detection. In isolated word recognition systems, accurate detection of the endpoints of a spoken word is important for two reasons, namely: 1) reliable word recognition is critically dependent on accurate endpoint detection 2) the computation for processing the speech is minimum when the endpoints are accurately located. Manuscript received September 8, 1980; revised January 26, 1981. This work is based on the M.S. thesis "Methods of endpoint detection for isolated word recognition," by L. F. Lame!, Massachusetts Institute of Technology, Cambridge, June 1980. L. F. Lamel was with Bell Laboratories, Murray Hill, NJ 07974. She is now with the Department of Electricai Engineering and Computer Science, Massachusetts Institute of Technology, Cambridge, MA 02139. L. R. Rabiner, A. E. Rosenberg, and J. G. Wilpon are with Bell Laboratories, Murray Hill, NJ 07974. This paper discusses the problem of accurately locating the endpoints of isolated words for recordings made over dialed-up telephone lines. Problems in endpoint detection arise from transients associated with the speaker and/or the transmission system (i.e., the telephone system). This type of background noise complicates the endpoint detection problem considerably. For example, often the beginning or end of an isolated word is obscured by speaker generated artifacts such as mouth noises, e.g., clicks, pops, lip smackings, and heavy breathing. Similar types of artifacts may be introduced by the telephone transmission system. In many applications, the problem is further complicated by nonstationary backgrounds where there may be concurrent background conversations and noises due to movements of chairs, door slams, etc. One way of minimizing the effects of such transient backgrounds is to use a closetalking, noise cancelling microphone for recording the speech signal; however, this approach is not feasible for transmission over telephone lines. Hence, an accurate endpoint detection method is an essential component of an isolated word recognizer which operates over dialed-up telephone lines. The endpoint detection techniques described in this paper assume that the desired spoken word is present in a given recording interval. This type of processing is reasonable for "nonreal-time" speech recognition systems. For "real-time" applications, the beginning of the spoken word must be detected before the word has ended (or else a large buffer storage is required). Many of the techniques to be described in this paper can be readily modified for such real time applications. The importance of accurate endpoint detection was noted by Martin [11, who showed that recognition performance was directly related to endpoint accuracy. Although an endpoint detector is an essential Component in all speech recognition systems, there has been very little published about specific algorithms for performing this task [2]. The reason for this is that most laboratory systems use reasonably clean recordings and, hence, there is no problem in finding endpoints from a simple heuristic, whereas commercial manufacturers, who have to worry both about real-time response and difficult recording conditions, are reluctant to publish their successful, working algorithms. As such, one purpose of this paper is to establish a framework for endpoint detection algorithms, and another is to provide an improved, heuristically conceived and carefully tested endpoint detection method. The essential components of a speech recognition system are feature extraction, pattern comparison, and a decision rule. 0096-3518/8 l/0800-0777$00 .75 © 1981 IEEE 778 IEEE TRANSACTIONS ON ACOUSTICS, SPEECH, AND SIGNAL PROCESSING, VOL. ASSP-29, NO. 4, AUGUST 1981 FEATUR1 ENDPOINT [J PATTE J DECISION I ORDERED UTTERANCEIESTRACTION DETECTION ]COMPARISONJ] RULE RECOGNVIION (Xl EXPLICIT ORDERED LIST OF FEATURE Li PATTERN J DEiN RECOGNITION CANDIDATES UTTERANCE [EXTRACTION ]COMPARISON ["1 RULE (b) IMPLICIT ORDERED LIST _________ ___________ ___________ ___________ OF RECOGNITION FEATURE ENDPOINT PATTERN DECISION I NDITES UTTERANCE [1RACTION ESTIMATES COMPARISON RULE ILl HYBRID ENDPOINTS Fig. 1. Block diagrams of canonic forms of the explicit, implicit, and hybrid endpoint detectors. Endpoint detection must be performed somewhere in the processing. The processing for finding word endpoints can be done explicitly, implicitly, or in a hybrid manner (i.e., a combination). These three approaches are illustrated in Fig. 1. For explicit endpoint detection methods, as shown in Fig. 1(a), the endpoint detection precedes and is independent of the recognition and decision stages of the recognizer. Typically, the endpoints of the spoken word are estimated from measurements made on the input speech and sent in a feed-forward manner to the next stage of the system. In a purely implicit approach to endpoint detection [Fig. 1(b)], the endpoints of the isolated word are determined solely by the recognition and decision phases of the word recognition system; i.e., there is no separate stage for endpoint detection. An implicit endpoint detection method would attempt recognition using all (or possible a large set of all) possible endpoint sets. The hybrid techniques [Fig. 1(c)] for endpoint detection incorporate ideas from both the explicit and implicit methods. Similar to the explicit approach, one or more estimates of each of the endpoints are obtained from features measured from the input utterance. Based on feedback from the recognition scores, alternative endpoint sets are considered. We consider all three types of endpoint detectors in this paper. The organization of the paper is as follows. In Section II, a brief review of an explicit and an implicit endpoint detector is given. In Section III, a hybrid endpoint detector is described. In Section IV, an experimental evaluation of the performance of the endpoint detectors in an isolated word recognition system is presented and discussed. A final summary is given in Section V. II. EXPLICIT AND IMPLICIT ENDPOINT DETECTION An example of an explicit endpoint detector is the energybased approach as described by Rabiner and Sambur [2]. Using the energy contour of the recorded signal and an appropriate set of thresholds, the "beginning" and "ending" of the word are estimated. In [2] , the zero-crossing contour was used to refine the word endpoints for words with fricative beginnings and endings. For telephone line recordings (with a 3 kHz bandwidth), the use of zero crossings is not effective. Hence, this feature is not used in the explicit endpoint detector which was evaluated in this paper. Only one endpoint set was obtained from this method, and a rejection occured when- REFERENCE P VT T E RN S SPEECH I FEATURE SET BEGINNING (81 PATTERN I DECISION WORD AND ENDING CE) SIMILARITY EXTRACTION FRAMES MEASUREMENT RULE J MODIFY BEGINNING 181 AND ENDING El FRAMES Fig. 2. Block diagram of a DTW-based implicit endpoint detector. ADAPTIVE () ENERGY PB(m) ENDPOINT B)m) LEVEL P PULSE P EQUALIZATION LDETECTION E Cm) ORDERING E(m) Fig. 3. Block diagram of the feed-forward processing of the hybrid endpoint detector. ever a consistent set of endpoints could not be found due to poor recordings, line transients, etc. An example of an implicit endpoint detector is given in Fig. 2 [3]. For this system, all (reasonable) combinations of beginning points (B) and ending points (E) are used and the best output from the pattern similarity stage and decision rule (lowest distance) is used to implicitly define the word endpoint as well as the recognized word. III. AN IMPROVED HYBRID ENDPOINT DETECTOR A block diagram of the proposed hybrid endpoint detector is given in Fig. 3 [4]. The input to the detector is the energy arrayR1(O), / = 1,2, . . ,L,whereListhenumberofframesin the recording interval. There are three blocks in the processing, namely, adaptive level equalization, energy pulse detection, and endpoint ordering. The function of each of these blocks is explained in subsequent sections. The output of the endpoint detector is the ordered set of beginning points B(m) and ending points E(m), where each set defines a word endpoint pair. For each endpoint pair, the pattern similarity and decision stages of the recognizer find the word with the smallest distance. If the distance obtained from one endpoint pair is sufficiently small, no other endpoint pairs are tried. Otherwise, the next pair of endpoints is tried, and the process is repeated. We will see later that the endpoint ordering algorithm is biased to include short events occurring prior to or following the main body of the word (e.g., stop releases, etc.) in the early endpoint pairs. Hence, the proposed method is applicable to vocabularies with similar words such as "for" and "afore," "tore" and "store," etc. A. The Adaptive Level Equalizer The first stage of the hybrid endpoint detector is the adaptive level equalizer which normalizes the (log) energy array to the background noise level. The equalized energy array R ,(O) is determined as k,(O)"log [R,(O)] — Q, ,L where Q is the "averaged" noise background level which is LAMEL etal.: IMPROVED ENDPOINT DETECTOR 779 Fig. 4. Example illustrating the use of energy thresholds to find beginning and ending frames of energy pulses. obtained as follows. First, minimum energy Emin is obtained as Emin = mm {log[R,(0)] }. 1 1L Then a histogram is taken of the low 10 dB of the log energy levels from the values of log [R,(0)J versus 1. A three-point averaging of the histogram is made, and the peak of the histogram is found. Q is chosen as the peak of the smoothed noise level histogram. The level equalized energy array has the property that during silence it fluctuates around the 0 dB level, and during speech it is considerably larger. Thus, absolute energy thresholds can be defined for detection of the presence of speech-like signals, as described in the next section. B. Energy Pulse Detection Based on the output of the adaptive level equalizer (0), a set of four energy thresholds k1, k2, k3, and k4 are defined as illustrated in Fig. 4. The purpose of these thresholds is to define the presence of an "energy pulse," i.e., a speech-like burst of energy during the recording interval. The assumption is made that the spoken word contains a sequence of one or more such energy pulses, and the only problem is to find those pulses and to determine which ones belong to the spoken word. The detection of energy pulses proceeds from left to right. Values of R1(0) are scanned (as 1 varies) and when R1(0) exceeds the first threshold k1, the frame number (A1) is recorded. IfR1(0) exceeds the higher threshold k2 before falling below k1, the beginning of an energy pulse is detected. The beginning point is nominally chosen as frame A1, unless the rise time (from A1 to A2) is too long, in which case the beginning point is chosen as frame A2. The ending frame is detected in a manner similar to the starting frame using thresholds k2 and k3. However, if the duration from A3 to A4 is too long (this typically indicates breathing at the end of the word), the frame A3 is used as the ending frame of the energy pulse. Two further tests are made on each detected energy pulse. The peak energy of the pulse is measured, and if it falls below the level threshold k4, the energy pulse is rejected as being part of the word. Also, the overall pulse duration is measured, and if it is too short (less than five frames, i.e., 75 ms), the energy pulse is rejected. The output of the energy pulse detector is a series of pulse beginning points PB(m) and pulse ending points PE(m), m = 1, 2, - ,MforMdetectedpulsesintherecordinginterval. When M =0 (he., no detected pulses), the recording is rejected and no endpoints are found. Checks are also made on whether pulses of significant energy occur at the boundaries of the recording interval. If so, the recording is again rejected. A flow diagram of the energy pulse detector is given in Fig. 5(a). C. Pulse Endpoint Ordering The purpose of the pulse endpoint ordering box is to determine, in order of likelthood (as defined below), the possible sets of word endpoint pairs from the set of pulse endpoints. The ordering logic is based on the following assumptions. 1) The isolated word whose endpoints are to be determined consists of one or more energy pulses. 2) The frame in the logenergy contour with the maximum energy wifi always be included within the spoken word. 3) The larger the stopgap between two energy pulses, the less likely that they come from one multiple-pulse word. 4) Energy pulses separated from the pulse containing the maximum energy by a stopgap of greater than 150 ms are unlikely to be part of the word. Based on these assumptions, the energy pulses are grouped into combinations of word-endpoint pairs and ordered. A flow diagram of the ordering procedure is given in Fig. 5(b), and Fig. 6 illustrates the method. In Fig. 6 we see three detected energy pulses, F1, F2, and F3, with pulse separations X1 and X2 frames. If both X1 and J2 are less than 150 ms, then the first pair of endpoints is chosen as A1 and A6, the second pair is chosen as A3 and A6 (assuming X1 >X2), the third pair is chosen as A1 and A4, and the fourth pair is chosen as A3 and A4. If X1 > 150 ms and X2 <150 ms, the ordered endpoint pairs are (A3, A6), (A3, A4), and (A1 ,A4). Finally, if both X1 and X2 are greater than 150 ms, the ordered pairs are (A3, A4), (A3, A6) and (A1 ,A4). This simple example illustrates how the ordering is sensitive to pulse separation. D. Feedback in the Hybrid Endpoint Detector As shown above, the output of the feed-forward portion of the hybrid endpoint detector is an ordered set of estimates of word endpoints. Each endpoint set is used in the recognizer to determine the word with the lowest distance score. Whenever the resulting distance score is too large, the recognizer decision stage requests the next set of endpoints and, if available, repeats the recognition comparisons. This process continues until all endpoint sets are used or until a reliable distance score is obtained. IV. EXPERIMENTAL EVALUATION OF THE ENDPOINT DETECTION METHODS The performance of each of the three endpoint detection algorithms was evaluated using a single-testing data set to provide a common basis for comparison. This testing set consisted of three repetitions of a 39 word vocabulary, recorded by each of ten talkers (four female and six male). •The talkers were problematic ones, i.e., they were known to generate >- Lz'J Ui 0 -J A2 Al A4 FRAME NUMBER 780 (a) IEEE TRANSACTIONS ON ACOUSTICS, SPEECH, AND SIGNAL PROCESSING, VOL. ASSP-29, NO. 4, AUGUST 1981 ENERGY PULSE DETECTOR PULSE REORDERING Fig. 5. (a) Flow charts of the energy pulse detector. (b) Flow chart of the pulse ordering procedure. (a) (a) (b) LAMEL etal.: IMPROVED ENDPOINT DETECTOR 781 Fig. 5 continued. (b) Flow chart of the pulse ordering procedure. (b) many of the artifacts discussed in the introduction while speaking isolated words. The 39 word vocabulary consisted of the letters of the alphabet, the digits, and the words /sTOP/, /ERROR/, and /REPEAT/ spoken in a randomized sequence. The resulting test set included 1161 utterances (nine words were lost due to manual recording errors). Of the recorded utterances, 40—60 percent included artifacts of some type. Each endpoint detector was evaluated on the basis of two criteria, namely, 1) the recognition accuracies achieved by the recognition system using the selected endpoints, and 2) the goodness or accuracy of the locations of the endpoints. The first criterion is a well-defined, quantitative measure of the actual performance of the endpoint detector within the recognition system. The second criterion, however, is highly subjective, as the accuracy of the endpoint detector is determined relative to a humanly defined standard. Manual location of the endpoints of an isolated word, determined from the time sequence of the samples, the log energy contour, or some other measurement, is subject to error, even given the knowledge of what word was spoken. Fortunately, the continuity of speech and the inherent redundancy in the speech allow the endpoints to vary by small amounts (perhaps one to three frames) without strongly affecting recognition accuracy. The rejection rate associated with each method was also measured. There is clearly a tradeoff between recognition accuracy and rejection rate. The object is to simultaneously obtain the highest recognition accuracy and the lowest rejection rate. The recognition accuracy is upper bounded by the recognition (I') I, L (b) 782 IEEE TRANSACTIONS ON ACOUSTICS, SPEECH, AND SIGNAL PROCESSING, VOL. ASSP-29, NO. 4, AUGUST 1981 Pa A1 A2 A3 A4A5 A6 Fig. 6. Example illustrating the use of temporal constraints in discriminating between adjacent energy pulses. scores obtained using clean speech (no artifacts) with manually obtained endpoints. For most applications, the recognition accuracy must attain a minimum performance level to be useful. The cost of a high rejection rate is an inconvenience to the user; if the rejection rate gets too large, the user will not be willing to use the system. A. Thelsolated Word Recognizer The isolated word recognizer used in the evaluation is the one described in [5]. Recognition is achieved by comparing the test pattern to a set of previously stored reference templates (using a DTW alignment procedure) and selecting the "closest match" (i.e., the reference with the smallest average distance) as the recognized word. The reference set of words consisted of twelve speaker-independent reference templates per word created using statistical clustering techniques [51. 1Clearly, any template and test set can be used to evaluate an endpoint detection method. I 114 35.1 71.6 8! 89,2 95.9 97 3 2 117 29.1 63.9 79.5 85 5 86.0 904 3 116 31.0 82.5 90.0 950 97.5 97 5 4 112 28.5 81.3 86.2 93.8 95 0 95.0 5 117 427 61.2 73.! 76 I 83,6 83.6 6 117 9.4 71.7 84.0 86.6 89.6 91 5 7 117 32.5 75.9 83.5 88.6 92.4 92.4 8 117 28.5 57.0 74.2 81.7 90 3 91 4 9 117 33.3 52.6 66.7 74.4 79.5 833 10 117 29.1 69.9 80.7 83:1 86.0 69.2 TOTs8L 1161 29.! 68.8 80.1 85.5 90.0 91.4 An average distance score is computed for the comparison between the test pattern and each time aligned reference pattern. The decision rule of the recognition system creates an ordered list of recognition candidates from the average distance scores; i.e., the reference word with the smallest average distance is the top candidate, the next smallest average distance is the second candidate, etc. B. Endpoint Detector Performance For the explicit endpoint detector, the performance criteria used were the recognition accuracy and the rejection rate. In evaluating the implicit endpoint detector, the performance criteria were the recognition accuracy, the rejection rate, and the relative distribution of distance scores (for correct and incorrect references). For the hybrid endpoint detector, the criteria were the number of endpoint pairs found, the recognition accuracy, and the rejection rate. 1) Performance of the Energy-Based Explicit Endpoint Detector: The results of the recognition tests on the energybased explicit endpoint detector are shown in Table I, which gives, for each talker, the rejection percentage and the recognition accuracy as a function of candidate position, i.e., the percentage of words that were correct in the top n positions of the ordered candidate list. As can be seen in the column labeled "% rejected," of the 1161 test words, 338,i.e., almost 30 percent, were rejected and a repeat requested. The rejection rates range across talkers from about 10 to 42 percent. These results show that the energy-based endpoint detector failed in a large percentage of trials. The average recognition accuracy for the top candidate is about 70 percent, ranging across talkers from a low of 50 percent to a high of over 80 percent. The overall recognition for the top five candidates ranges from 83 to 98 percent with an average of 91 percent. These results indicate that the explicit endpoint detector is reasonably accurate when the recording is relatively clean, but it tends to reject the recording in the presence of artifacts. 2) Performance of the DTW-Based Implicit Endpoint Detector: For the implicit endpoint detector based on DTW matching, an important performance indicator is the distribution of the distance scores for both the correct and the incorrect reference templates. It was found that, using a totally unconstrained beginning and ending point DTW algorithm, the distances between the tests and the correct references are generally small and in the range one would expect for a correct reference-test word recognition distance. By way of example, n8 9E a Rn -ML MX TABLE I PERFORMANCE RESULTS FOR ENERGY-BASED EXPLICIT ENDPOINT DETECTOR Talker Number of words spoken 0 Candidate Position rejected I 2 3 4 5 MLI MXI (b) (b) Fig. 5 continued. (b) Flow chart of the pulse ordering procedure. LAMEL etal.: IMPROVED ENDPOINT DETECTOR 783 2 Fig. 7(a) shows a histogram of distances obtained when the test and reference words were the same for one of the talkers. The data plotted include all the tokens recorded for that talker. The solid curve is the measured histogram of distances and the dashed curve is a Gaussian fit to the data. The average distance for the correct words is seen to be about 0.4 with a standard deviation of about 0.1. Thus, the distances obtained using the test and the correct reference pattern are seen to be reasonably small. What is equally or, perhaps, more important is the distribution of distances when the test pattern is compared to incorrect reference templates. This result is illustrated in Fig. 7(b) for the same talker where the test and reference words were different. It can be seen that there is substantial overlap in these two distributions, thereby implying a substantial error in recognition. A similar set of histograms are shown in Fig. 8 for a different speaker. Here, there is almost total overlap in the distributions, implying an even larger error rate that in the previous example. Talker Number words spoken Recognition Accuracy candidate position 2 3 4 5 I 2 3 4 5 6 7 8 9 10 114 117 116 112 117 117 117 117 117 117 27.2 36.8 56.! 65.8 76.3 25.6 34.2 41.9 47.0 47.9 44,0 64.7 70.7 75.9 81.0 55.4 67.0 75.9 80.4 83.0 7.0 28.2 37.6 49.6 564 7.7 14.5 23.9 32.5 37.6 33.3 53.9 60.7 70.9 76.! 29.1 47.9 61.5 68.4 72.7 27.4 48.7 59.0 63.2 70.1 28.2 44.4 58.! 65.8 72.7 TOTAL 1161 29.4 43.9 54.4 61.8 67.3 Words Spoken Number of endpoint sets I 2 3 mean I 2 3 4 . 5 6 7 8 9 10 114 117 116 112 117 117 117 117 117 117 94 19 0 93 23 I 00 16 0 102 10 0 97 20 0 99 18 0 99 18 0 102 14 0 92 22 I 94 22 0 1.17 1.2! 1.14 1.09 1.17 1.15 1.15 1.12 .2! 1.19 TOTAL 116! 972 182 2 , The conclusion drawn from these examples is that a totally unconstrained beginning and ending point DTW algorithm allowed the recognizer too much freedom in the determination of the endpoints. By allowing the algorithm to discard any portions of the test, it was able to match the test pattern as well or better to the incorrect reference patterns than to the correct reference patterns. These conclusions are verified in the recognition accuracies obtained using this implementation of an implicit endpoint detector, as shown in Table II, which shows recognition accuracy as a function of candidate position. Although the rejection rate is zero for all talkers, the recognition scores are too low for reliable recognition. For the top candidate, the recognition scores range from less than 10 to 55 percent correct across talkers. Even for the top five candidates, the recognition scores only range from 37 to 83 percent, with an average of less than 70 percent. Overall recognition for the implicit endpoint detector using five candidates is lower than for the top candidate using the explicit endpoint detector. 3) Performance of the Energy Hybrid Endpoint Detector: For the hybrid endpoint detector, one important factor is the number of endpoint pairs located, as this is an indication of the potential gained by using feedback from the recognizer. The number of endpoint pairs located for each talker is given in Table III. The data show that, on average, only slightly more than one endpoint pair is found. The effectiveness of the' screening operations of the endpoint detector is reflected in the small number of endpoint pairs found by eliminating energy pulses corresponding to extraneous artifacts. Since for the majority of the tests (84 percent), only one endpoint pair was located, it is reasonable to use this hybrid endpoint detec- TABLE II PERFORMANCE RESULTS FOR DTW-BASED IMPLICIT ENDPOINT DETECTOR (a) DISTANCE FOR MATCHES (b) DISTANCE FOR MISMATCHES of average word distance for matches (a) and misone talker using an unconstrained endpoint DTW TABLE III STATISTICS ON THE NUMBER OF ENDPOINT SETS FOR THE HYBRID ENDPOINT DETECTOR I—z00 Fig. 7. Histograms matches (b) for algorithm. z 00 Fig.8. Histograms of average word distance for matches (a) and mismatches (b) for another talker. (a) DISTANCE FOR MATCHES .'t (b) DISTANCE FOR MISMATCHES 784 IEEE TRANSACTIONS ON ACOUSTICS, SPEECH, AND SIGNAL PROCESSING, VOL. ASSP-29, NO. 4, AUGUST 1981 Talker Number Words Spokes Number of rejects Recogeitius Accuracy I 2 - 3 4 5 t 2 3 4 5 6 7 8 9 to t 14 t 17 t 6 t 12 17 t 7 t 7 t 7 t 7 t t7 I 0 o 0 0 0 0 I 2t 79.6 97.3 98.2 99.t 00.0 73.5 86.3 90.6 95.7 96.6 84.5 93.t 95.7 98.2 99.t 8t.t 86.6 89.3 92.0 92.9 74.3 8t.t 88.9 91.4 9t.4 7t.8 84.6 87.2 89.7 92.3 74.4 92.3 96.6 97.4 98.3 6t.2 77.6 86.2 93.1 94.8 70.4 60.9 84.3 85.2 89.6 78.4 87.9 95.7 97.4 99.t TOTAL I 61 5 74.9 86.8 9t .3 93.9 95.4 tor with only the top estimated endpoint pair as an explicit endpoint detector. The recognition accuracies obtained using only the top endpoint pair are given in Table IV for the individual talkers. The overall recognition is about 75 percent for the top candidate position and 95 percent for the top five candidate positions. Comparing these results to those of the explicit endpoint detector shows there is a 10—15 percent increase in the recognition accuracy for the top candidate for most of the talkers. Averaged over all of the talkers, there is 4-6 percent improvement in recognition accuracy for all candidate positions. The advantage of supplying several estimates of the endpoints is demonstrated by the use of a distance threshold for requesting additional endpoint pairs during the decision stage of the recognition process. If the recognition score obtained using the best estimated endpoint pair does not provide a sufficiently small distance, recognition with the second endpoint pair may be attempted. Setting a low distance threshold for reliable recognition will cause recognition to be attempted with successive endpoint pairs unless the first match is a very good one. It can be seen from the data in Table III that even if an extremely low threshold is used, only one or two endpoint pairs will be used for recognition. Setting a high distance threshold increases the likelthood that the recognized word with the first endpoint pair will have a recognition score below the threshold and, thus, be acceptable. The threshold should be set such that if the first set of endpoints are accurate, the corresponding recognition distance will fall within the acceptable range. At the same time, if the top endpoint pair is incorrect, it is desirable that the recognition score lie above the acceptable threshold. It is important to stress that the distance threshold does not affect the number of endpoint pairs located, but does determine how many of the endpoint candidates are used. The optimum distance threshold was determined for each of the ten talkers. These results are summarized in Table V. A detailed examination of the recognition results shows that the optimum distance threshold should lie somewhere between 0.35 and 0.4 for highest recognition accuracy. For some of the talkers, the threshold was irrelevant. This implies that for these talkers, either the first candidate was always correct, or any improvement in the recognition of some words was counteracted by errors introduced for other words. Only for two of the talkers did the recognition improve significantly by using the distance thresholds. For these, talkers 2 and 9, there was a uniform increase of 2—3 percent in the recognition Talker Distusce optimum threshold 1 >0.3 2 <0.4 3 >0.35 4 irrelevant S irrelevant 6 >0.6 7 irrelevant 8 irrelevant 9 <0.4 tO <0.4 Fig. 9. Plots of recognition accuracy versus number of candidates for three endpoint detectors and for hand-edited words. accuracy for all candidate positions. The data above suggest that the use of alternate sets of endpoints provides some improvement in recognition accuracy for problematic talkers. This capability adds little to the computational requirements of the system and has proved to be valuable during on-line recognition tests with untrained talkers. C Summary of Performance Scores A comparison of the recognition scores obtained by all three methods of endpoint detection in the word recognition test is shown in Fig. 9. This figure shows plots of the recognition accuracy as a function of candidate position. It can be clearly seen that the hybrid endpoint detector yields significantly higher recognition results than either the explicit or implicit methods used here. An even stronger resuli is that the hybrid endpoint detector attains its recognition accuracy with a rejection rate of less than 0.5 percent, whereas the explicit endpoint detector has a rejection rate of almost 30 percent for the same test set. The implicit algorithm has a recognition accuracy far below that of the explicit and hybrid algorithms. A final performance comparison is given in the top curve of Fig. 9, labeled "clean" speech, which shows the recognition accuracy obtained from hand-edited endpoints with highly trained talkers [5]. The vocabulary was the same as that used in this test. The hybrid endpoint detector is seen to achieve recognition accuracies within 3—5 percent of those obtained TABLE IV RECOGNITION SCORES FOR THE HYBRID ENDPOINT DETECTOR TABLE V OPTIMUM DISTANCE THRESHOLDS FOR THE HYBRID ENDPOINT DETECTOR hOES REJECTS) 100 - CLEAN 90 BC a 70 a 60 • 50 40 30 110% REJECTS) 1 2 3 4 NUMBER OF CANDIIATES 5 6 LAMEL etal.: IMPROVED ENDPOINT DETECTOR 785 with the clean speech. It is important to keep in mind that the results using the hybrid method were obtained using a testing data set in which 40—60 percent of the utterances contained some form of artifact, many of which would have been discarded (due to the uncertainty as to where the actual endpoints would be placed) even by hand-editing. Thus, the results obtained by the hybrid endpoint detector are seen to approach those of hand-edited clean speech. V. DISCUSSION AND SUMMARY The results presented in the previous sections lead to the following general conclusions. 1) Simple approaches to endpoint detection are doomed to failure under some sets of recording conditions. These failures can be manifested as either rejections of the recording or recognition errors due to improper location of endpoints. 2) Pattern classification techniques are not readily applied to the endpoint detection problem since there is a strong overlap between "speech" sounds and "nonspeech" sounds, especially humanly produced transients. 3) Providing a great deal of latitude in the specification of the endpoint locations tends to degrade the recognition performance severely. Hence, accurate location of endpoints is a strong requirement for a practical recognition system. As applied to the general endpoint detection classes, these conclusions imply that implicit methods of endpoint detection will perform poorly, whereas a sophisticated explicit technique can perform well. Clearly the hybrid methods, being a superset of the explicit techniques, should always perform as well as the explicit techniques. One of the main results of this work was the development of an improved hybrid (explicit) endpoint detector. The improvements consisted of an optimized strategy for finding endpoints using a three-pass approach in which energy pulses were located, edited, and the endpoint pairs scored in order of most likely candidates. The performance of this improved technique approached the performance of the "ideal" endpoint detector— i.e., the recognition accuracy was comparable to the recognition accuracy obtained on high quality recordings, and the rejection rate was negligible (less than 0.5 percent). One final issue is the capability of incorporating the hybrid endpoint detector into a real-time recognizer. The required modifications are simple. First, the adaptive level equalization is performed on any reasonably "quiet" interval—i.e., when no speech is present. The energy pulse detection stage is carried out in real time (i.e., all processing is left to right) and the pulse locations are stored in a temporary buffer. When no energy pulses are detected for, say, 200 ms, the word is assumed over and the endpoint ordering algorithm is then used to provide the beginning and endihg point arrays required for recognition. The real-time version of the algorithm is currently in use in a hardware implementation of the recognizer of[5] (see [6]). REFERENCES [11 T. Martin, "Applications of limited vocabulary recognition systems," in Rec. 1974 Symp. Speech Recognition, D. R. Reddy, Ed. New York: Academic, 1975, pp.55—71. [21 L. R. Rabiner and M. R. Sambur, "An algorithm for determining the endpoints of isolated utterances," Bell Syst. Tech. J., vol.54, pp. 297—315, Feb. 1975. [3] C. S. Myers, "A comparative study of several dynamic time warping algorithms for speech recognition," M.S. thesis, Massachusetts Inst. Technol., Cambridge, Feb. 1980. [4] L. F. Lamel, "Methods of endpoint detection for isolated word recognition," M.S. thesis, Massachusetts Inst. Technol., Cambridge, June 1980. [5] L. R. Rabiner, S. E. Levinson, A. E. Rosenberg, and J. G. Wilpon, "Speaker independent recognition of isolated words using clustering techniques," IEEE Trans. Acoust., Speech, Signal Processing, vol. ASSP-27, pp. 336 —349, Aug. 1979. [6] J. G. Ackenhusen and L. R. Rabiner, "Microprocessor implementation of an LPC-based isolated word recognizer," in Proc. 1980 BTL!WE Microprocessor Symp., Sept. 1980, pp. 35-42. 